<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'seq' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/Seq/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'seq' Dialect</h1><p>Types and operations for seq dialect
The <code>seq</code> dialect is intended to model digital sequential logic.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#seqclock_gate-circtseqclockgateop><code>seq.clock_gate</code> (::circt::seq::ClockGateOp)</a></li><li><a href=#seqcompreg-circtseqcompregop><code>seq.compreg</code> (::circt::seq::CompRegOp)</a></li><li><a href=#seqcompregce-circtseqcompregclockenabledop><code>seq.compreg.ce</code> (::circt::seq::CompRegClockEnabledOp)</a></li><li><a href=#seqfifo-circtseqfifoop><code>seq.fifo</code> (::circt::seq::FIFOOp)</a></li><li><a href=#seqfirmem-circtseqfirmemop><code>seq.firmem</code> (::circt::seq::FirMemOp)</a></li><li><a href=#seqfirmemread_port-circtseqfirmemreadop><code>seq.firmem.read_port</code> (::circt::seq::FirMemReadOp)</a></li><li><a href=#seqfirmemread_write_port-circtseqfirmemreadwriteop><code>seq.firmem.read_write_port</code> (::circt::seq::FirMemReadWriteOp)</a></li><li><a href=#seqfirmemwrite_port-circtseqfirmemwriteop><code>seq.firmem.write_port</code> (::circt::seq::FirMemWriteOp)</a></li><li><a href=#seqfirreg-circtseqfirregop><code>seq.firreg</code> (::circt::seq::FirRegOp)</a></li><li><a href=#seqhlmem-circtseqhlmemop><code>seq.hlmem</code> (::circt::seq::HLMemOp)</a></li><li><a href=#seqread-circtseqreadportop><code>seq.read</code> (::circt::seq::ReadPortOp)</a></li><li><a href=#seqwrite-circtseqwriteportop><code>seq.write</code> (::circt::seq::WritePortOp)</a></li></ul></li><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#firmeminitattr>FirMemInitAttr</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#firmemtype>FirMemType</a></li><li><a href=#hlmemtype>HLMemType</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition</h2><h3 id=seqclock_gate-circtseqclockgateop><code>seq.clock_gate</code> (::circt::seq::ClockGateOp)</h3><p><em>Safely gates a clock with an enable signal</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.clock_gate` $input `,` $enable (`,` $test_enable^)? attr-dict
</code></pre><p>The <code>seq.clock_gate</code> enables and disables a clock safely, without glitches,
based on a boolean enable value. If the enable operand is 1, the output
clock produced by the clock gate is identical to the input clock. If the
enable operand is 0, the output clock is a constant zero.</p><p>The <code>enable</code> operand is sampled at the rising edge of the input clock; any
changes on the enable before or after that edge are ignored and do not
affect the output clock.</p><p>The <code>test_enable</code> operand is optional and if present is OR&rsquo;d together with
the <code>enable</code> operand to determine whether the output clock is gated or not.</p><pre tabindex=0><code>%gatedClock = seq.clock_gate %clock, %enable : i1
%gatedClock = seq.clock_gate %clock, %enable, %test_enable : i1, i1
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>test_enable</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=seqcompreg-circtseqcompregop><code>seq.compreg</code> (::circt::seq::CompRegOp)</h3><p><em>Register a value, storing it for one cycle</em></p><p>See the Seq dialect rationale for a longer description
Traits: AlwaysSpeculatableImplTrait, SameVariadicOperandSize</p><p>Interfaces: Clocked, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Resettable</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr><tr><td style=text-align:center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>resetValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr></tbody></table><h3 id=seqcompregce-circtseqcompregclockenabledop><code>seq.compreg.ce</code> (::circt::seq::CompRegClockEnabledOp)</h3><p><em>When enabled, register a value</em></p><p>See the Seq dialect rationale for a longer description
Traits: AlwaysSpeculatableImplTrait, SameVariadicOperandSize</p><p>Interfaces: Clocked, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Resettable</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr><tr><td style=text-align:center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>clockEnable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>resetValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr></tbody></table><h3 id=seqfifo-circtseqfifoop><code>seq.fifo</code> (::circt::seq::FIFOOp)</h3><p><em>A high-level FIFO operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.fifo` `depth` $depth
              custom&lt;FIFOAFThreshold&gt;($almostFullThreshold, type($almostFull))
              custom&lt;FIFOAEThreshold&gt;($almostEmptyThreshold, type($almostEmpty))
              `in` $input `rdEn` $rdEn `wrEn` $wrEn `clk` $clk `rst` $rst attr-dict `:` type($input)
</code></pre><p>This operation represents a high-level abstraction of a FIFO. Access to the
FIFO is structural, and thus may be composed with other core RTL dialect
operations.
The fifo operation is configurable with the following parameters:</p><ol><li>Depth (cycles)</li><li>Almost full/empty thresholds (optional). If not provided, these will
be asserted when the FIFO is full/empty.</li></ol><p>Like <code>seq.hlmem</code> there are no guarantees that all possible fifo configuration
are able to be lowered. Available lowering passes will pattern match on the
requested fifo configuration and attempt to provide a legal lowering.</p><p>Traits: AttrSizedResultSegments</p><p>Interfaces: OpAsmOpInterface</p><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>depth</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td style=text-align:center><code>almostFullThreshold</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr><tr><td style=text-align:center><code>almostEmptyThreshold</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr></tbody></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a signless integer bitvector</td></tr><tr><td style=text-align:center><code>rdEn</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>wrEn</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>a signless integer bitvector</td></tr><tr><td style=text-align:center><code>full</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>empty</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>almostFull</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>almostEmpty</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=seqfirmem-circtseqfirmemop><code>seq.firmem</code> (::circt::seq::FirMemOp)</h3><p><em>A FIRRTL-flavored memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.firmem` (`sym` $inner_sym^)? `` custom&lt;ImplicitSSAName&gt;($name)
              $readLatency `,` $writeLatency `,` $ruw `,` $wuw
              attr-dict `:` type($memory)
</code></pre><p>The <code>seq.firmem</code> op represents memories lowered from the FIRRTL dialect. It
is used to capture some of the peculiarities of what FIRRTL expects from
memories, while still representing them at the HW dialect level.</p><p>A <code>seq.firmem</code> declares the memory and captures the memory-level parameters
such as width and depth or how read/write collisions are resolved. The read,
write, and read-write ports are expressed as separate operations that take
the declared memory as an operand.</p><p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), OpAsmOpInterface</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>readLatency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>writeLatency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>ruw</code></td><td style=text-align:center>circt::seq::RUWAttr</td><td>Read-Under-Write Behavior</td></tr><tr><td style=text-align:center><code>wuw</code></td><td style=text-align:center>circt::seq::WUWAttr</td><td>Write-Under-Write Behavior</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>init</code></td><td style=text-align:center>::circt::seq::FirMemInitAttr</td><td>Memory initialization information</td></tr><tr><td style=text-align:center><code>prefix</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>output_file</code></td><td style=text-align:center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>A FIRRTL-flavored memory</td></tr></tbody></table><h3 id=seqfirmemread_port-circtseqfirmemreadop><code>seq.firmem.read_port</code> (::circt::seq::FirMemReadOp)</h3><p><em>A memory read port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.firmem.read_port` $memory `[` $address `]` `,` `clock` $clock
              (`enable` $enable^)?
              attr-dict `:` type($memory)
</code></pre><p>The <code>seq.firmem.read_port</code> op represents a read port on a <code>seq.firmem</code>
memory. It takes the memory as an operand, together with the address to
be read, the clock on which the read is synchronized, and an optional
enable. Omitting the enable operand has the same effect as passing a
constant <code>true</code> to it.</p><p>Interfaces: InferTypeOpInterface, MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>A FIRRTL-flavored memory</td></tr><tr><td style=text-align:center><code>address</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>signless integer</td></tr></tbody></table><h3 id=seqfirmemread_write_port-circtseqfirmemreadwriteop><code>seq.firmem.read_write_port</code> (::circt::seq::FirMemReadWriteOp)</h3><p><em>A memory read-write port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.firmem.read_write_port` $memory `[` $address `]` `=` $writeData `if` $mode `,` `clock` $clock
              (`enable` $enable^)? (`mask` $mask^)?
              attr-dict `:` type($memory) (`,` type($mask)^)?
</code></pre><p>The <code>seq.firmem.read_write_port</code> op represents a read-write port on a
<code>seq.firmem</code> memory. It takes the memory as an operand, together with the
address and data to be written, a mode operand indicating whether the port
should perform a read (<code>mode=0</code>) or a write (<code>mode=1</code>), the clock on which
the read and write is synchronized, an optional enable, and and optional
write mask. Omitting the enable operand has the same effect as passing a
constant <code>true</code> to it. Omitting the write mask operand has the same effect
as passing an all-ones value to it. A write mask operand can only be present
if the <code>seq.firmem</code> specifies a mask width; otherwise it must be omitted.</p><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: InferTypeOpInterface, MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>A FIRRTL-flavored memory</td></tr><tr><td style=text-align:center><code>address</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>writeData</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>mode</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>readData</code></td><td>signless integer</td></tr></tbody></table><h3 id=seqfirmemwrite_port-circtseqfirmemwriteop><code>seq.firmem.write_port</code> (::circt::seq::FirMemWriteOp)</h3><p><em>A memory write port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.firmem.write_port` $memory `[` $address `]` `=` $data `,` `clock` $clock
              (`enable` $enable^)? (`mask` $mask^)?
              attr-dict `:` type($memory) (`,` type($mask)^)?
</code></pre><p>The <code>seq.firmem.write_port</code> op represents a write port on a <code>seq.firmem</code>
memory. It takes the memory as an operand, together with the address and
data to be written, the clock on which the write is synchronized, an
optional enable, and and optional write mask. Omitting the enable operand
has the same effect as passing a constant <code>true</code> to it. Omitting the write
mask operand has the same effect as passing an all-ones value to it. A write
mask operand can only be present if the <code>seq.firmem</code> specifies a mask width;
otherwise it must be omitted.</p><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>A FIRRTL-flavored memory</td></tr><tr><td style=text-align:center><code>address</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>data</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>signless integer</td></tr></tbody></table><h3 id=seqfirreg-circtseqfirregop><code>seq.firreg</code> (::circt::seq::FirRegOp)</h3><p><em>Register with preset and sync or async reset</em></p><p><code>firreg</code> represents registers originating from FIRRTL after the lowering
of the IR to HW. The register is used as an intermediary in the process
of lowering to SystemVerilog to facilitate optimisation at the HW level,
compactly representing a register with a single operation instead of
composing it from register definitions, always blocks and if statements.</p><p>The <code>data</code> output of the register accesses the value it stores. On the
rising edge of the <code>clk</code> input, the register takes a new value provided
by the <code>next</code> signal. Optionally, the register can also be provided with
a synchronous or an asynchronous <code>reset</code> signal and <code>resetValue</code>, as shown
in the example below.</p><pre tabindex=0><code>%name = seq.firreg %next clock %clk [ sym @sym ]
    [ reset (sync|async) %reset, %value ]
    [ preset value ] : type
</code></pre><p>Implicitly, all registers are pre-set to a randomized value.</p><p>A register implementing a counter starting at 0 from reset can be defined
as follows:</p><pre tabindex=0><code>%zero = hw.constant 0 : i32
%reg = seq.firreg %next clock %clk reset sync %reset, %zero : i32
%one = hw.constant 1 : i32
%next = comb.add %reg, %one : i32
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, SameVariadicOperandSize</p><p>Interfaces: Clocked, ConditionallySpeculatable, InferTypeOpInterface, MemoryEffectOpInterface (MemoryEffectOpInterface), NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Resettable</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource, MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}, MemoryEffects::Effect{}</p><h4 id=attributes-4>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>preset</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr><tr><td style=text-align:center><code>isAsync</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>next</code></td><td>any type</td></tr><tr><td style=text-align:center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>resetValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr></tbody></table><h3 id=seqhlmem-circtseqhlmemop><code>seq.hlmem</code> (::circt::seq::HLMemOp)</h3><p><em>Instantiate a high-level memory.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.hlmem` $sym_name $clk `,` $rst attr-dict `:` type($handle)
</code></pre><p>See the Seq dialect rationale for a longer description
Interfaces: Clocked, OpAsmOpInterface, Symbol</p><h4 id=attributes-5>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>Multi-dimensional memory type</td></tr></tbody></table><h3 id=seqread-circtseqreadportop><code>seq.read</code> (::circt::seq::ReadPortOp)</h3><p><em>Structural read access to a seq.hlmem, with an optional read enable signal.</em></p><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: OpAsmOpInterface</p><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>latency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>Multi-dimensional memory type</td></tr><tr><td style=text-align:center><code>addresses</code></td><td>a signless integer bitvector</td></tr><tr><td style=text-align:center><code>rdEn</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>readData</code></td><td>any type</td></tr></tbody></table><h3 id=seqwrite-circtseqwriteportop><code>seq.write</code> (::circt::seq::WritePortOp)</h3><p><em>Structural write access to a seq.hlmem</em></p><h4 id=attributes-7>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>latency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>Multi-dimensional memory type</td></tr><tr><td style=text-align:center><code>addresses</code></td><td>a signless integer bitvector</td></tr><tr><td style=text-align:center><code>inData</code></td><td>any type</td></tr><tr><td style=text-align:center><code>wrEn</code></td><td>1-bit signless integer</td></tr></tbody></table><h2 id=attribute-definition>Attribute definition</h2><h3 id=firmeminitattr>FirMemInitAttr</h3><p>Memory initialization information</p><p>Syntax:</p><pre tabindex=0><code>#seq.firmem.init&lt;
  mlir::StringAttr,   # filename
  bool,   # isBinary
  bool   # isInline
&gt;
</code></pre><p>This attribute captures what the initial contents of a memory should be.
At the moment this is modeled primarily with simulation in mind, where the
memory contents are pre-loaded from a file at simulation startup.</p><p>The <code>filename</code> specifies a file on disk that contains the initial contents
for this memory. If <code>isBinary</code> is set, the file is interpreted as a binary
file, otherwise it is treated as hexadecimal. This is modeled after the
<code>$readmemh</code> and <code>$readmemb</code> SystemVerilog functions. If <code>isInline</code> is set,
the initialization is emitted directly in the memory model; otherwise it is
split out into a separate module that can be bound in.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>filename</td><td style=text-align:center><code>mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>isBinary</td><td style=text-align:center><code>bool</code></td><td></td></tr><tr><td style=text-align:center>isInline</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h2 id=type-definition>Type definition</h2><h3 id=firmemtype>FirMemType</h3><p>A FIRRTL-flavored memory</p><p>Syntax:</p><pre tabindex=0><code>!seq.firmem&lt;
  uint64_t,   # depth
  uint32_t,   # width
  std::optional&lt;uint32_t&gt;   # maskWidth
&gt;
</code></pre><p>The <code>!seq.firmem</code> type represents a FIRRTL-flavored memory declared by a
<code>seq.firmem</code> operation. It captures the parameters of the memory that are
relevant to the read, write, and read-write ports, such as width and depth.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>depth</td><td style=text-align:center><code>uint64_t</code></td><td></td></tr><tr><td style=text-align:center>width</td><td style=text-align:center><code>uint32_t</code></td><td></td></tr><tr><td style=text-align:center>maskWidth</td><td style=text-align:center><code>std::optional&lt;uint32_t></code></td><td></td></tr></tbody></table><h3 id=hlmemtype>HLMemType</h3><p>Multi-dimensional memory type</p><p>Syntax:</p><pre tabindex=0><code>hlmem-type ::== `hlmem` `&lt;` dim-list element-type `&gt;`
</code></pre><p>The HLMemType represents the type of an addressable memory structure. The
type is inherently multidimensional. Dimensions must be known integer values.</p><p>Note: unidimensional memories are represented as &lt;1x{element type}> -
&lt;{element type}> is illegal.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h2>'seq' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/ title="Pipeline Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Pipeline Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/ title="Seq(uential) Dialect Rationale">Next - Seq(uential) Dialect Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/CombPasses/></a></li><li><a href=https://circt.llvm.org/docs/DCPasses/></a></li><li><a href=https://circt.llvm.org/docs/IbisPasses/></a></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>